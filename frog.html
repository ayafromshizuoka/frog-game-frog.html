<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no">
    <title>カエルシンカ - Frog Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background: #e0f2f1; font-family: sans-serif; }
        canvas { display: block; margin: 0 auto; background: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
        #score { position: absolute; top: 20px; left: 20px; font-size: 24px; color: #2e7d32; font-weight: bold; }
        #line { position: absolute; top: 150px; left: 50%; transform: translateX(-50%); width: 400px; border-top: 2px dashed #ff4500; pointer-events: none; }
        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.9); padding: 20px; border-radius: 10px; text-align: center; border: 3px solid #2e7d32; }
        button { background: #2e7d32; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="line"></div>
    <div id="game-over">
        <h2 style="color: #2e7d32;">Game Over!</h2>
        <p id="final-score"></p>
        <button onclick="location.reload()">もう一度あそぶ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, World, Bodies, Events, Composite } = Matter;

        const WIDTH = 400;
        const HEIGHT = 600;
        const IMG_BASE_URL ="./"; 
        const LINE_Y = 150;

        // カエル9種類に合わせてサイズとスコアを調整
        const FROG_DATA = [
            { radius: 55, score: 2 }, { radius: 62, score: 4 }, { radius: 72, score: 8 },
            { radius: 82, score: 16 }, { radius: 92, score: 32 }, { radius: 102, score: 64 },
            { radius: 112, score: 128 }, { radius: 122, score: 256 }, { radius: 135, score: 512 }
        ];

        const engine = Engine.create();
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: { width: WIDTH, height: HEIGHT, wireframes: false, background: '#fff' }
        });
        const runner = Runner.create();
        Render.run(render);
        Runner.run(runner, engine);

       // 【修正後】地面を少し下げ、厚みを薄くしてピタッと着地させます
      const ground = Bodies.rectangle(WIDTH/2, HEIGHT - 5, WIDTH, 10, { isStatic: true, render: { fillStyle: '#81c784' } });
        const leftWall = Bodies.rectangle(-25, HEIGHT/2, 50, HEIGHT, { isStatic: true });
        const rightWall = Bodies.rectangle(WIDTH + 25, HEIGHT/2, 50, HEIGHT, { isStatic: true });
        World.add(engine.world, [ground, leftWall, rightWall]);

        let score = 0;
        let currentLevel = 0;
        let isClickable = true;
        let gameOverTriggered = false;

        function createFrog(x, y, level) {
            const data = FROG_DATA[level];
            const frog = Bodies.circle(x, y, data.radius, {
                restitution: 0.4,
                label: "frog_" + level,
                render: {
                    sprite: {
                        // 保存したkaeru1.png〜kaeru9.pngを読み込みます
                        texture: `${IMG_BASE_URL}kaeru${level + 1}.png`,
                        xScale: (data.radius * 2) / 100,
                        yScale: (data.radius * 2) / 100
                    }
                }
            });
            frog.level = level;
            return frog;
        }

       window.addEventListener("mousedown", (e) => { dropFrog(e.clientX); });
       window.addEventListener("touchstart", (e) => { dropFrog(e.touches[0].clientX); });

      function dropFrog(clientX) {
          if (!isClickable || gameOverTriggered) return;
          isClickable = false;

          const rect = render.canvas.getBoundingClientRect();
          let x = clientX - rect.left;
          
          // 壁からはみ出さないように調整
          const radius = FROG_DATA[currentLevel].radius;
          x = Math.max(radius, Math.min(x, WIDTH - radius));

          const newFrog = createFrog(x, 50, currentLevel);
          World.add(engine.world, newFrog);

          setTimeout(() => { 
              // 最初に出現するのはレベル0〜2の小さいカエル
              currentLevel = Math.floor(Math.random() * 3);
              isClickable = true; 
          }, 800);
      }

        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach((pair) => {
                const { bodyA, bodyB } = pair;
                if (bodyA.label.startsWith("frog_") && bodyA.label === bodyB.label) {
                    const level = bodyA.level;
                    if (level < FROG_DATA.length - 1) {
                        const newX = (bodyA.position.x + bodyB.position.x) / 2;
                        const newY = (bodyA.position.y + bodyB.position.y) / 2;
                        World.remove(engine.world, [bodyA, bodyB]);
                        const nextFrog = createFrog(newX, newY, level + 1);
                        World.add(engine.world, nextFrog);
                        score += FROG_DATA[level + 1].score;
                        document.getElementById("score").innerText = `Score: ${score}`;
                    }
                }
            });
        });

        Events.on(engine, 'afterUpdate', () => {
            if (gameOverTriggered) return;
            const bodies = Composite.allBodies(engine.world);
            for (let body of bodies) {
                if (body.label.startsWith("frog_") && body.position.y < LINE_Y && body.velocity.y < 0.1) {
                    gameOverTriggered = true;
                    document.getElementById("final-score").innerText = `最終スコア: ${score}`;
                    document.getElementById("game-over").style.display = "block";
                    break;
                }
            }
        });
    </script>
</body>

</html>

